# importing the needed packages.
import pandas as pd
import numpy as np
import pathlib
from typing import Union, Tuple
import matplotlib.pyplot as plt
import matplotlib
import matplotlib.pyplot as plt
#matplotlib.use('Agg')
import re

class QuestionnaireAnalysis: # initiating a new class called "QuestionnaireAnalysis"
    """
    Reads and analyzes data generated by the questionnaire experiment.
    Should be able to accept strings and pathlib.Path objects.
    """

    def __init__(self, data_fname: Union[pathlib.Path, str]): # parameters: are a data_fname called by a string or a pathlib.Path object representing the file path to the data.
        self.data_fname = pathlib.Path(data_fname) 
        if not self.data_fname.exists(): # cheking if the file exists and if not an error is raised.
            raise ValueError(f"File {self.data_fname} does not exist.")
        self.data = None #initializing the data to None and later these Nones would be filled with the loaded data.
        

    def read_data(self):
        """Reads the json data located in self.data_fname into memory, to
        the attribute self.data.
        """
        self.data = pd.read_json(self.data_fname) # using pandas.read_json() to read the JSON file and storing it in the self.data attribute.

   
    def show_age_distrib(self) -> Tuple[np.ndarray, np.ndarray]:
        """Calculates and plots the age distribution of the participants.

       Returns
       -------
       hist : np.ndarray
       Number of people in a given bin
       bins : np.ndarray
       Bin edges
        """
        removed_NAN_ages = self.data['age'].dropna() # dropping the Nans in the age coloumn.
        hist, bins = np.histogram(removed_NAN_ages, bins=np.arange(0, 110, 10)) # a histogram from 1 to 100 in steps of 10.
        plt.hist(removed_NAN_ages, bins=bins, edgecolor='black')
        plt.title('Age Distribution')
        plt.xlabel('Age')
        plt.ylabel('Number of Participants')
        plt.grid(True)
        plt.show()
        return hist, bins

    def remove_rows_without_mail(self) -> pd.DataFrame:
        """Checks self.data for rows with invalid emails, and removes them.

       Returns
       -------
       df : pd.DataFrame
       A corrected DataFrame, i.e. the same table but with the erroneous rows removed and
       the (ordinal) index after a reset.
         """
        valid_email_pattern = re.compile(r'^[^@]+@[^@]+\.[^@]+$') # defining what a valid email should look like using a regular expression. 
        valid_emails = self.data['email'].apply(lambda x: bool(valid_email_pattern.match(str(x)))) # appling this pattern to the 'email' column to filter out invalid emails.
        self.data = self.data[valid_emails].reset_index(drop=True) # updating self.data by removing invalid email  and re indexing the the dataFrame.
        return self.data

    def fill_na_with_mean(self) -> Tuple[pd.DataFrame, np.ndarray]:
        """Finds, in the original DataFrame, the subjects that didn't answer
        all questions, and replaces that missing value with the mean of the
        other grades for that student.

        Returns
        -------
      df : pd.DataFrame
      The corrected DataFrame after insertion of the mean grade
      arr : np.ndarray
      Row indices of the students that their new grades were generated
        """
        nan_rows_indices = self.data.index[self.data[['q1', 'q2', 'q3', 'q4', 'q5']].isna().any(axis=1)].to_numpy() # identifing rows with missing values in any of the 'q1' to 'q5' columns and storing their indices.
        grades_subset = self.data[['q1', 'q2', 'q3', 'q4', 'q5']] # selecting the grade columns from the DataFrame.
        row_averages = grades_subset.mean(axis=1) # computing the average for each row.
        averages_df = pd.DataFrame({col: row_averages for col in grades_subset.columns}) # creating a dataFrame where missing values will be replaced by  the row average.
        imputed_grades = grades_subset.combine_first(averages_df)
        self.data.update(imputed_grades) # updating the main dataFrame with the imputed grades
        return self.data, nan_rows_indices


    def score_subjects(self, maximal_nans_per_sub: int = 1) -> pd.DataFrame:
        """Calculates the average score of a subject and adds a new "score" column
    with it.

    If the subject has more than "maximal_nans_per_sub" NaN in his grades, the
    score should be NA. Otherwise, the score is simply the mean of the other grades.
    The datatype of score is UInt8, and the floating point raw numbers should be
    rounded down.

    Parameters
    ----------
    maximal_nans_per_sub : int, optional
        Number of allowed NaNs per subject before giving a NA score.

    Returns
    -------
    pd.DataFrame
        A new DF with a new column - "score".
    """
        question_columns = [f"q{i}" for i in range(1, 6)]  # creating a list of question columns to work with.
        subset = self.data[question_columns] # extracting the relevant columns into a dataFrame.
        self.data["score"] = np.floor(subset.sum(axis=1) / subset.notna().sum(axis=1)).astype("UInt8") # calculating the mean score for each participant, rounding down and converting to UInt8.
        nan_threshold_exceeded = subset.isna().sum(axis=1) > maximal_nans_per_sub # identifying rows where the number of NaNs exceeds the allowed threshold.
        self.data.loc[nan_threshold_exceeded, "score"] = pd.NA # using a direct assignment to set the 'score' to pd.NA where the threshold is exceeded.
        return self.data

    def correlate_gender_age(self) -> pd.DataFrame:
        """Looks for a correlation between the gender of the subject, their age
    and the score for all five questions.

Returns
-------
pd.DataFrame
    A DataFrame with a MultiIndex containing the gender and whether the subject is above
    40 years of age, and the average score in each of the five questions.
"""
        df_filtered = self.data.dropna(subset=['age']).copy()  # dropping rows where 'age' is NaN and work on a copy to avoid a warning.
        df_filtered['age_group'] = df_filtered['age'] > 40 # creating a boolean column to categorize age as above or below 40.
        df_grouped = df_filtered.groupby(['gender', 'age_group'])[['q1', 'q2', 'q3', 'q4', 'q5']].mean() # grouping by gender and age_group'then calculating the mean for 'q1' to 'q5'.
        df_grouped.index = df_grouped.index.set_names('age', level=1) # renaming the age_group level to age.
        return df_grouped
